import AsyncStorage from '@react-native-async-storage/async-storage';
import React, {useState, useCallback, useRef, useEffect} from 'react';
import {
  View,
  Dimensions,
  Alert,
  TouchableOpacity,
  Text,
  ActivityIndicator,
} from 'react-native';
import {
  GestureDetector,
  Gesture,
  GestureHandlerRootView,
} from 'react-native-gesture-handler';
import Animated, {
  useAnimatedStyle,
  useSharedValue,
  withSpring,
  runOnJS,
} from 'react-native-reanimated';
import {captureRef} from 'react-native-view-shot';

const {width: screenWidth} = Dimensions.get('window');

const ImageCropper = ({
  imageUri,
  fileId,
  onCropComplete,
  containerWidth = screenWidth * 0.8,
  autoGenerateDelay = 500, // Delay in ms after user stops interacting
}) => {
  // Calculate container dimensions with 3:4 ratio
  const cropWidth = containerWidth;
  const cropHeight = (containerWidth * 4) / 3;

  // Refs
  const cropViewRef = useRef();
  const autoGenerateTimeoutRef = useRef(null);

  // Animated values
  const scale = useSharedValue(1);
  const savedScale = useSharedValue(1);
  const translateX = useSharedValue(0);
  const translateY = useSharedValue(0);
  const savedTranslateX = useSharedValue(0);
  const savedTranslateY = useSharedValue(0);

  // Shared values for scale limits (accessible on UI thread)
  const minScale = useSharedValue(0.5);
  const maxScale = useSharedValue(5);

  // Image dimensions state
  const [imageDimensions, setImageDimensions] = useState({width: 0, height: 0});
  const [isGenerating, setIsGenerating] = useState(false);
  const [isImageLoading, setIsImageLoading] = useState(true);
  const [cropData, setCropData] = useState({});
  const [isInitialized, setIsInitialized] = useState(false);

  // Load crop data from storage
  useEffect(() => {
    const loadCropData = async () => {
      try {
        const storedData = await AsyncStorage.getItem('cropData');
        if (storedData) {
          setCropData(JSON.parse(storedData));
        }
      } catch (error) {
        console.error('Error loading crop data:', error);
      }
    };
    loadCropData();
  }, []);

  // Save crop data to storage
  useEffect(() => {
    const saveCropData = async () => {
      try {
        await AsyncStorage.setItem('cropData', JSON.stringify(cropData));
      } catch (error) {
        console.error('Error saving crop data:', error);
      }
    };
    if (Object.keys(cropData).length > 0) {
      saveCropData();
    }
  }, [cropData]);

  // Initialize crop data for new files
  useEffect(() => {
    if (imageUri && fileId && !cropData[fileId]) {
      setCropData(prev => ({
        ...prev,
        [fileId]: {
          crop: {x: 0, y: 0},
          zoom: 0,
          minZoom: 0,
          translateX: 0,
          translateY: 0,
          scale: 0,
        },
      }));
    }
  }, [fileId, imageUri, cropData]);

  // Reset loading state when imageUri changes
  useEffect(() => {
    if (imageUri) {
      setIsImageLoading(true);
      setIsInitialized(false);
      setHasGeneratedInitialCrop(false); // Reset initial crop flag
    }
  }, [imageUri, fileId]);

  // Calculate initial scale to fill crop container (no empty space)
  const calculateInitialScale = useCallback(() => {
    if (!imageDimensions.width || !imageDimensions.height) return 1;

    const scaleX = cropWidth / imageDimensions.width;
    const scaleY = cropHeight / imageDimensions.height;

    // Use Math.max to fill the container completely (no empty space)
    return Math.max(scaleX, scaleY);
  }, [cropWidth, cropHeight, imageDimensions]);

  // Function to automatically generate cropped image
  const autoGenerateCroppedImage = useCallback(async () => {
    if (
      !imageDimensions.width ||
      !imageDimensions.height ||
      !cropViewRef.current ||
      isGenerating
    ) {
      return;
    }

    try {
      setIsGenerating(true);

      // Capture the crop container as image
      const uri = await captureRef(cropViewRef.current, {
        format: 'jpg',
        quality: 1,
        width: cropWidth * 2,
        height: cropHeight * 2,
      });

      if (onCropComplete) {
        onCropComplete(fileId, uri);
      }

      return uri;
    } catch (error) {
      console.error('Error auto-generating cropped image:', error);
    } finally {
      setIsGenerating(false);
    }
  }, [
    imageDimensions,
    cropWidth,
    cropHeight,
    onCropComplete,
    fileId,
    isGenerating,
  ]);

  // Debounced auto-generation function (only for user interactions)
  const scheduleAutoGeneration = useCallback(() => {
    // Only schedule if user has interacted (initial crop already generated)
    if (!hasGeneratedInitialCrop) return;

    // Clear existing timeout
    if (autoGenerateTimeoutRef.current) {
      clearTimeout(autoGenerateTimeoutRef.current);
    }

    // Schedule new auto-generation
    autoGenerateTimeoutRef.current = setTimeout(() => {
      autoGenerateCroppedImage();
    }, autoGenerateDelay);
  }, [autoGenerateCroppedImage, autoGenerateDelay, hasGeneratedInitialCrop]);

  // Function to apply saved crop state
  const applySavedCropState = useCallback(() => {
    if (cropData[fileId] && imageDimensions.width && imageDimensions.height) {
      const savedCropState = cropData[fileId];

      // Only apply saved state if it has valid scale value (not initial 0)
      if (savedCropState.scale && savedCropState.scale > 0) {
        scale.value = savedCropState.scale;
        savedScale.value = savedCropState.scale;
        translateX.value = savedCropState.translateX || 0;
        translateY.value = savedCropState.translateY || 0;
        savedTranslateX.value = savedCropState.translateX || 0;
        savedTranslateY.value = savedCropState.translateY || 0;
      } else {
        // Use initial scale calculation for new images
        const initialScale = calculateInitialScale();

        scale.value = initialScale;
        savedScale.value = initialScale;
        translateX.value = 0;
        translateY.value = 0;
        savedTranslateX.value = 0;
        savedTranslateY.value = 0;
      }
    } else {
      // Calculate initial scale to fit image within container (fully zoomed out)
      const initialScale = calculateInitialScale();

      scale.value = initialScale;
      savedScale.value = initialScale;
      translateX.value = 0;
      translateY.value = 0;
      savedTranslateX.value = 0;
      savedTranslateY.value = 0;
    }

    setIsInitialized(true);
  }, [cropData, fileId, imageDimensions, calculateInitialScale]);

  // Get image dimensions when loaded
  const handleImageLoad = useCallback(event => {
    const {width, height} = event.nativeEvent.source;
    setImageDimensions({width, height});

    // Hide loading indicator
    setIsImageLoading(false);
  }, []);

  // Apply saved crop state after image loads and crop data is available
  useEffect(() => {
    if (
      !isImageLoading &&
      imageDimensions.width &&
      imageDimensions.height &&
      !isInitialized
    ) {
      applySavedCropState();
    }
  }, [isImageLoading, imageDimensions, isInitialized, applySavedCropState]);

  // Track if initial crop has been generated
  const [hasGeneratedInitialCrop, setHasGeneratedInitialCrop] = useState(false);

  // Auto-generate initial crop when component is ready (only once)
  useEffect(() => {
    if (
      isInitialized &&
      !isImageLoading &&
      !hasGeneratedInitialCrop &&
      cropData[fileId]?.scale > 0
    ) {
      // Generate initial crop after a short delay
      setTimeout(() => {
        autoGenerateCroppedImage();
        setHasGeneratedInitialCrop(true);
      }, 100);
    }
  }, [
    isInitialized,
    isImageLoading,
    hasGeneratedInitialCrop,
    cropData,
    fileId,
    autoGenerateCroppedImage,
  ]);

  // Handle image load error
  const handleImageError = useCallback(() => {
    setIsImageLoading(false);
    Alert.alert('Error', 'Failed to load image');
  }, []);

  // Function to save current crop state and trigger auto-generation
  const saveCropStateAndAutoGenerate = useCallback(() => {
    if (fileId) {
      setCropData(prev => ({
        ...prev,
        [fileId]: {
          ...prev[fileId],
          scale: scale.value,
          translateX: translateX.value,
          translateY: translateY.value,
        },
      }));
    }

    // Schedule auto-generation
    scheduleAutoGeneration();
  }, [fileId, scheduleAutoGeneration]);

  // Constrain translation within bounds
  const constrainTranslation = useCallback(
    (x, y, currentScale) => {
      'worklet';
      if (!imageDimensions.width || !imageDimensions.height) return {x, y};

      const scaledWidth = imageDimensions.width * currentScale;
      const scaledHeight = imageDimensions.height * currentScale;

      const maxTranslateX = Math.max(0, (scaledWidth - cropWidth) / 2);
      const maxTranslateY = Math.max(0, (scaledHeight - cropHeight) / 2);

      const constrainedX = Math.max(-maxTranslateX, Math.min(maxTranslateX, x));
      const constrainedY = Math.max(-maxTranslateY, Math.min(maxTranslateY, y));

      return {x: constrainedX, y: constrainedY};
    },
    [cropWidth, cropHeight, imageDimensions],
  );

  // Pan gesture with real-time constraints
  const panGesture = Gesture.Pan()
    .onStart(() => {
      savedTranslateX.value = translateX.value;
      savedTranslateY.value = translateY.value;
    })
    .onUpdate(event => {
      const newX = savedTranslateX.value + event.translationX;
      const newY = savedTranslateY.value + event.translationY;

      // Apply constraints in real-time during dragging
      const constrained = constrainTranslation(newX, newY, scale.value);
      translateX.value = constrained.x;
      translateY.value = constrained.y;
    })
    .onEnd(() => {
      // Final constraint check with spring animation
      const constrained = constrainTranslation(
        translateX.value,
        translateY.value,
        scale.value,
      );
      translateX.value = withSpring(constrained.x);
      translateY.value = withSpring(constrained.y);

      // Save crop state and trigger auto-generation
      runOnJS(saveCropStateAndAutoGenerate)();
    });

  // Pinch gesture with minimum scale constraint
  const pinchGesture = Gesture.Pinch()
    .onStart(() => {
      savedScale.value = scale.value;
    })
    .onUpdate(event => {
      const newScale = savedScale.value * event.scale;

      // Use shared values for scale limits (accessible on UI thread)
      if (newScale >= minScale.value && newScale <= maxScale.value) {
        scale.value = newScale;
      }
    })
    .onEnd(() => {
      // Constrain translation after scaling with spring animation
      const constrained = constrainTranslation(
        translateX.value,
        translateY.value,
        scale.value,
      );
      translateX.value = withSpring(constrained.x);
      translateY.value = withSpring(constrained.y);
      scale.value = withSpring(scale.value);

      // Save crop state and trigger auto-generation
      runOnJS(saveCropStateAndAutoGenerate)();
    });

  // Combine gestures
  const composedGesture = Gesture.Simultaneous(panGesture, pinchGesture);

  // Animated style for the image
  const animatedStyle = useAnimatedStyle(() => {
    return {
      transform: [
        {translateX: translateX.value},
        {translateY: translateY.value},
        {scale: scale.value},
      ],
    };
  });

  // Reset function - now uses the calculated initial scale
  const resetTransform = useCallback(() => {
    if (!imageDimensions.width || !imageDimensions.height) return;

    const initialScale = calculateInitialScale();

    // Animate scale and trigger generation only after it's done
    scale.value = withSpring(initialScale, {}, isFinished => {
      if (isFinished && hasGeneratedInitialCrop) {
        runOnJS(scheduleAutoGeneration)();
      }
    });

    savedScale.value = initialScale;
    translateX.value = withSpring(0);
    translateY.value = withSpring(0);
    savedTranslateX.value = 0;
    savedTranslateY.value = 0;

    // Update crop data
    setCropData(prev => ({
      ...prev,
      [fileId]: {
        ...prev[fileId],
        scale: initialScale,
        translateX: 0,
        translateY: 0,
      },
    }));
  }, [
    calculateInitialScale,
    fileId,
    scheduleAutoGeneration,
    hasGeneratedInitialCrop,
  ]);

  // Update scale limits when image dimensions change
  useEffect(() => {
    if (imageDimensions.width && imageDimensions.height) {
      const initialScale = calculateInitialScale();
      minScale.value = initialScale;
    }
  }, [imageDimensions, calculateInitialScale, minScale]);

  // Cleanup timeout on unmount
  useEffect(() => {
    return () => {
      if (autoGenerateTimeoutRef.current) {
        clearTimeout(autoGenerateTimeoutRef.current);
      }
    };
  }, []);

  return (
    <GestureHandlerRootView style={styles.container}>
      <View
        ref={cropViewRef}
        style={[styles.cropContainer, {width: cropWidth, height: cropHeight}]}>
        {/* Loading indicator */}
        {(isImageLoading || !isInitialized) && (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color="#e93c00" />
            <Text style={styles.loadingText}>
              {isImageLoading ? 'Loading image...' : 'Initializing...'}
            </Text>
          </View>
        )}

        <GestureDetector gesture={composedGesture}>
          <Animated.View style={styles.gestureContainer}>
            <Animated.Image
              source={{uri: imageUri}}
              style={[
                {
                  width: imageDimensions.width || cropWidth,
                  height: imageDimensions.height || cropHeight,
                  opacity: isImageLoading || !isInitialized ? 0 : 1,
                },
                animatedStyle,
              ]}
              onLoad={handleImageLoad}
              onError={handleImageError}
              resizeMode="contain"
            />
          </Animated.View>
        </GestureDetector>
      </View>

      {/* Crop overlay - positioned outside the capture area */}
      <View
        style={[styles.cropOverlay, {width: cropWidth, height: cropHeight}]}
        pointerEvents="none">
        <View style={styles.cropBorder} />
      </View>

      {/* Controls - Only Reset button remains */}
      <View style={styles.controls}>
        <TouchableOpacity
          style={[
            styles.button,
            (isImageLoading || !isInitialized) && styles.disabledButton,
          ]}
          onPress={resetTransform}
          disabled={isImageLoading || !isInitialized}>
          <Text style={styles.buttonText}>Reset</Text>
        </TouchableOpacity>
      </View>
    </GestureHandlerRootView>
  );
};

const styles = {
  container: {
    alignItems: 'center',
    padding: 20,
  },
  cropContainer: {
    backgroundColor: '#000',
    overflow: 'hidden',
    borderRadius: 8,
    position: 'relative',
    justifyContent: 'center',
    alignItems: 'center',
  },
  gestureContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  cropOverlay: {
    position: 'absolute',
    top: 20, // Adjust based on container padding
    justifyContent: 'center',
    alignItems: 'center',
    borderRadius: 8,
  },
  cropBorder: {
    width: '100%',
    height: '100%',
    borderRadius: 8,
  },
  loadingContainer: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    zIndex: 1,
  },
  loadingText: {
    color: '#fff',
    marginTop: 10,
    fontSize: 16,
  },
  controls: {
    marginTop: 20,
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    gap: 15,
  },
  button: {
    backgroundColor: '#6c757d',
    paddingHorizontal: 20,
    paddingVertical: 10,
    borderRadius: 8,
  },
  disabledButton: {
    backgroundColor: '#cccccc',
  },
  buttonText: {
    color: '#fff',
    fontSize: 16,
    fontWeight: '600',
  },
  statusContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  statusText: {
    color: '#666',
    fontSize: 14,
  },
};

export default ImageCropper;
